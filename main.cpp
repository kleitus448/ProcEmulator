/** -------------------------------------------------------------- *
 * ИВМО-01-20, Павел Комаров, Вариант 4 = 0100
 * Гарвардская архитектура, 2-х адрес. пространство
 * Максимальное значение в массиве
 *
 * Характеристики устройства:
 *
 * 1. Размер команды - 32 бита
 * |---------------|---------|-------------|------------|
 * | Номер команды | Литерал | 1-ый адрес  | 2-ой адрес |
 * |---------------|---------|-------------|------------|
 * |     5 бита    | 17 бит  |    5 бит    |    5 бит   |
 * |---------------|---------|-------------|------------|
 *
 * 2. Кол-во регистров общего назначения (РОН) - 16.
 * Размерность регистров - 16 бит.
 *
 * 3. Память команд - 32 ячейки по 32 бита = 1024 бита = 128 байт
 *    Память данных -  64 ячейки по 16 бит = 1024 бита = 128 байт
 *
 * 4. Флаги - рав-во нулю, больше нуля, меньше нуля, переполнение.
 * --------------------------------------------------------------- */

#include <conio.h>      // Библиотека для работы с функцией getch
#include <cstdlib>      // Библиотека для работы с функцией system
#include <iostream>     // Библиотека для работы с консольными потоками ввода/вывода
#include <fstream>      // Библиотека для работы с файловыми потоками ввода/вывода
#include "print_lib.h"  // Библиотека для дебаг-вывода
#include <windows.h>    // Библиотека для изменения размеров консольного окна
#include <string>
#include <fstream>
#include <regex>
#include <algorithm>

// Флаги условий
#define FLAG 15 // Номер регистра флагов
#define EZ 1    // Флаг " == 0"
#define GZ 2    // Флаг "  > 0"
#define LZ 3    // Флаг "  < 0"

// Коды клавиш для действий
// внутри контроллера
#define KEY_UP 72
#define KEY_DOWN 80
#define KEY_LEFT 75
#define KEY_RIGHT 77
#define KEY_O 79
#define KEY_Y 121
#define KEY_N 110
#define KEY_Q 113

#define KEY_0 48
#define KEY_1 49
#define KEY_2 50
#define KEY_3 51
#define KEY_4 52
#define KEY_5 53
#define KEY_6 54

#define EMPTY 0
#define ADD   1
#define SUB   2
#define AND   3
#define OR    4
#define XOR   5
#define NOT   6
#define SHL   7
#define SHR   8
#define IREG  9
#define IMEM  10
#define RTR   11
#define MTM   12
#define RTM   13
#define MTR   14
#define JEZ   15
#define JGZ   16
#define JLZ   17
#define JP    18

// Инициализация памяти команд
const unsigned short int cmem_size = 32;
const unsigned short int cmem_addr_size = 5;
const unsigned short int cmem_data_size = 32;
unsigned int cmem[cmem_size] = {};

// Инициализация памяти данных
const unsigned short int dmem_size = 32;
const unsigned short int dmem_addr_size = 5;
const unsigned short int dmem_data_size = 16;
short int dmem[dmem_size] = {};

// Инициализация массива регистров
const unsigned short int reg_size = 16;
const unsigned short int reg_addr_size = 4;
const unsigned short int reg_data_size = 16;
short int reg[reg_size] = {};

// Размеры частей команды
int cmdtype_size = 5; int literal_size = 17;
int op1_size = 5; int op2_size = 5;

int cmd_count = 19;
string cmd_list[] = {"empty", "add", "sub", "and", "or", "xor", "not",
                     "shl", "shr", "ireg", "imem", "rtr", "mtm", "rtm",
                     "mtr", "jez", "jgz", "jlz", "jp"};

using namespace std;

//const int data_addr_begin = // Первый адрес в ОП для записи данных
//const int prog_data_begin = // Первый адрес в ОП для записи программы

/** ------------------ *
    ПРОТОТИПЫ ФУНКЦИЙ
  * ------------------ */

// Функция для получения информации из файла с даннными/командами
string get_info_from_file();

// Функция для сохранения информации в файл с даннными/командами
void save_info_in_file(string info);

// Функция для загрузки сохранённого состояния устройства
void load_saved_state();

// Функция для отображения начального меню работы с процессором
void show_menu();

// Функция для настройки работы процессора
void config_output_debug();

// Функция работы архитектуры
void architecture_work();

// Функция сохранения состояния архитектуры
void save_current_state();

// Фунцкия для парсинга программного кода и перевода его в двоичный код
string parse_program(string program);

// Функция для загрузки программы (в двоичном коде) в память
void load_program_to_memory(string program);

// Функция для загрузки данных в память
void load_data_to_memory(string data);

// Функция для отладочных выводов
void output_debug(char settings);

char output_debug_settings = 0xFF;

/** ----------------- *
    ОСНОВНАЯ ФУНКЦИЯ
  * ----------------- */

int main() {
    HWND console = GetConsoleWindow();
    RECT ConsoleRect;
    GetWindowRect(console, &ConsoleRect);
    MoveWindow(console, ConsoleRect.left, ConsoleRect.top, 1280, 720, TRUE);
    setlocale(LC_ALL, "Russian"); // русский язык

    cout << "Консольная эмуляция модели процессорного ядра." << endl << endl;
    load_saved_state();
    show_menu(); // Отображение меню
    cout << "\n\nНачало эмуляции работы устройства...\n\n";
    architecture_work(); // Эмуляция работы устройства
    cout << "\nРабота с устройством завершена.\n";
    save_current_state();
}

/** ----------------------------------------- *
    ОПРЕДЕЛЕНИЕ ФУНКЦИЙ ДЛЯ РАБОТЫ С ФАЙЛАМИ
  * ----------------------------------------- */

// Функция для получения информации из файла с даннными/командами
string get_info_from_file() {

    bool file_flag = false;
    string path, text, line;

    while (!file_flag) {
        cout << endl << "Укажите путь к файлу (полный или относительно директории эмулятора): ";
        cin >> path;
        ifstream file(path);
        if (file.is_open()) {
            while (getline(file, line))
                text += line + "\n";
            file.close();
            file_flag = true;
        }
        else {
            cout << "Неправильный путь. Попробуйте ещё раз,\n";
        }
    }
    return text;
}

// Функция для сохранения информации в файл с даннными/командами
void save_info_in_file(string info) {

    bool file_flag = false;
    string path, text, line;

    while (!file_flag) {
        cout << "Укажите путь к файлу (полный или относительно директории эмулятора): ";
        cin >> path;
        ofstream file(path);
        file << info;
        file.close();
        file_flag = true;
    }
}

/** -------------------------------------------------------- *
    ОПРЕДЕЛЕНИЕ ФУНКЦИЙ ДЛЯ РАБОТЫ С КОМАНДАМИ И ПРОГРАММАМИ
  * -------------------------------------------------------- */

// Фунцкия для парсинга программного кода и перевода его в двоичный код
string parse_program(string program) {
    regex label("^[A-Za-z0-9]+:(.*)");
    regex addr2_regex("^(add|sub|and|or|xor|shl|shr|rtr|mtm|rtm|mtr){1}(\\s)+([0-9])+,(\\s)*([0-9])+$");
    regex addr1_regex("^(not|jez|jgz|jlz|jp){1}(\\s)+([0-9])+$");
    regex literal_regex("^(ireg|imem){1}(\\s)+[0-9]+,(\\s)*([0-9])+$");
    regex cmd_regex("[^\\n]+");

    string binary_program = "";
    string cmdtype, literal, op1, op2;
    string space = " ";

    auto program_begin = sregex_iterator(program.begin(), program.end(), cmd_regex);
    auto program_end = sregex_iterator();

    cout << program << endl;


    bool label_match, addr1_match, addr2_match, literal_match;
    for (auto i = program_begin; i != program_end; ++i) {
        string cmd = (*i).str();
        cout << "CURRENT CMD: " << cmd << endl;
        label_match = regex_match(cmd, label);
        addr2_match = regex_match(cmd, addr2_regex);
        addr1_match = regex_match(cmd, addr1_regex);
        literal_match = regex_match(cmd, literal_regex);
        cout << "AFTER REGEX: " << addr2_match << addr1_match << literal_match << endl;

        if (!(addr1_match || addr2_match || literal_match)) {
            cout << endl << "error" << endl;
            return "ERROR";
        }

        // Парсинг кода команды
        cmdtype = cmd.substr(0, cmd.find(space));
        for (int j = 0; j < cmd_count; j++) {
            transform(cmdtype.begin(), cmdtype.end(), cmdtype.begin(), ::tolower);
            if (cmdtype.compare(cmd_list[j]) == 0) {
                cmdtype = get_binary(j, cmdtype_size);
                break;
            }
        }
        cmd.erase(0, cmd.find(space) + 1);

        // Парсинг 1-го адреса
        op1 = get_binary(stoi(cmd.substr(0, cmd.find(space))), op1_size);
        cmd.erase(0, cmd.find(space) + 1);

        // Парсинг 2-го адреса
        if (addr2_match)
            op2 = get_binary(stoi(cmd.substr(0, cmd.find(space))), op2_size);
        else
            op2 = get_binary(0, op2_size);

        // Парсинг литерала
        if (literal_match)
            literal = get_binary(stoi(cmd.substr(0, cmd.find(space))), literal_size);
        else
            literal = get_binary(0, literal_size);

        binary_program += cmdtype + literal + op1 + op2 + "\n";
        cout << "BINARY: " << cmdtype << " ";
        cout << literal << " " << op1 << " " << op2 << endl << endl;
        getch();
    }

    return binary_program;
};

// Функция для загрузки программы (в двоичном коде) в память
void load_program_to_memory(string program) {
    if (program == "ERROR") {
        cout << endl << program << endl;
    }
    else {
        regex cmd_regex("[^\\n]+");
        auto program_begin = sregex_iterator(program.begin(), program.end(), cmd_regex);
        auto program_end = sregex_iterator();
        int cmem_pointer = 0; // ?
        for (auto i = program_begin; i != program_end; ++i) {
            cmem[cmem_pointer] = stoi((*i).str(), 0, 2);
            cmem_pointer++;
        }
        cout << "Записанная программа:" << endl << program;
    }
        /*cout << "Программа заняла " << "n" << " ячеек." << endl;
    cout << "Начальный адрес: " << "" << endl;
    cout << " Конечный адрес: " << "" << endl;
    if (false) {
        cout << "Программа не помещается в память, начиная с посл. адреса записи." << endl;
        cout << "Дальнейшие действия:";
        cout << "1. Записать программу с 0-го адреса памяти команд.";
        cout << "2. Продолжить запись (непоместившиеся команды запишутся с 0-го адреса).";
        cout << "3. Отмена записи";
        cout << "Выберите действие: ";
        while(key_flag) {}
    }*/
};

/** -------------------------------------------------------- *
    ОПРЕДЕЛЕНИЕ ФУНКЦИЙ ДЛЯ РАБОТЫ С ПАМЯТЬЮ ДАННЫХ
  * -------------------------------------------------------- */

// Функция для загрузки данных в память
void load_data_to_memory(string data) {
    string colon = ":";
    regex line_regex("[^\\n]+");

    auto file_begin = sregex_iterator(data.begin(), data.end(), line_regex);
    auto file_end = sregex_iterator();
    for (auto i = file_begin; i != file_end; ++i) {
        string data = (*i).str();
        string addr = data.substr(0, data.find(colon));
        data.erase(0, data.find(colon) + 1);
        dmem[stoi(addr)] = stoi(data);
    }
};

/** ------------------------------------------------------ *
    ОПРЕДЕЛЕНИЕ ФУНКЦИЙ ДЛЯ НАСТРОЙКИ И РАБОТЫ УСТРОЙСТВА
  * ------------------------------------------------------ */

// Функция для отображения начального меню работы с архитектурой
void show_menu() {
    bool start_processor = false; // Флаг запуска работы процессора

    // Ввод программы вручную
    // Ввод данных вручную

    // Запуск программы
    cout << "0. Настройки отладочных выводов." << endl;
    cout << "1. Загрузить программу из файла (двоичный код)." << endl;
    cout << "2. Загрузить программу из файла (Assembler)." << endl;
    cout << "3. Загрузить данные для ОП." << endl;
    cout << "4. Вывести память команд." << endl;
    cout << "5. Вывести память данных." << endl;
    cout << "6. Начать работу процессора." << endl;

    cout << endl << "Выберите действие: ";
    int key; //  Код нажатой кнопки
    while (!start_processor) {
        switch(key = getch()) {
            case KEY_0: { // Настройки отладочных выводов
                config_output_debug();
                cout << endl << "Выберите действие: ";
                break;
            }

            case KEY_1: { // Загрузить программу из файла (двоичный код)
                load_program_to_memory(get_info_from_file());
                cout << endl << "Выберите действие: ";
                break;
            }

            case KEY_2: { // Загрузить программу из файла (Assembler)
                load_program_to_memory(parse_program(get_info_from_file()));
                cout << endl << "Выберите действие: ";
                break;
            }

            case KEY_3: { // Загрузить данные для ОП
                string data = get_info_from_file();
                load_data_to_memory(data);
                cout << endl << "Выберите действие: ";
                break;
            }

            case KEY_4: { // Вывести память команд
                output_debug(2);
                cout << endl << "Выберите действие: ";
                break;
            }

            case KEY_5: { // Вывести память данных
                output_debug(4);
                cout << endl << "Выберите действие: ";
                break;
            }

            case KEY_6: { // Начать работу процессора
                start_processor = true;
                break;
            }

            /*case KEY_7: {
                start_processor = true;
                break;
            }
            default: break;*/
        }
    }
}

// Функция для настройки работы с архитектурой
void config_output_debug() {
    string settings;

    cout << endl << "Настройка отладочных выводов." << endl;
    cout << "Текущие настройки: ";
    print_binary(output_debug_settings, 8); cout << endl;
    cout << "xx1 - вывод регистров РОН" << endl;
    cout << "x1x - вывод памяти команд" << endl;
    cout << "1xx - вывод памяти данных" << endl;
    cout << "Введите число в двоичном коде: ";

    cin >> settings;
    output_debug_settings = (char) stoi(settings, 0, 2);
}

// Функция работы архитектуры
void architecture_work() {

    // Вычисляем макс. значение типа команды и литерала
    int cmdtype_max = 1; for (int i = 0; i < cmdtype_size; i++) cmdtype_max *= 2;
    int literal_max = 1; for (int i = 0; i < literal_size; i++) literal_max *= 2;
    int op1_max = 1; for (int i = 0; i < op1_size; i++) op1_max *= 2;
    int op2_max = 1; for (int i = 0; i < op2_size; i++) op2_max *= 2;

    bool  prev_flag = false;  // Флаг перехода к предыдущей команде
    bool  next_flag = false;  // Флаг перехода к следующей команде
    bool debug_flag = false;  // Флаг перехода к настройкам
    bool   end_flag = false;  // Флаг перехода к завершению работы

    int cmd; //буфер команд
    int pc = 0; //счетчик команд

    //  Разбитая команда
    int cmdtype, literal, op1, op2;

    int key = 0;
    while(!end_flag) {
        cout << "*";
        for (int i = 0; i < 150; i++) cout << "-";
        cout << "*" << endl << endl;

        // Выбираем команду по адресу из счётчика команд
        cmd = cmem[pc];

        // Путём сдвига и операцией "И" с битовой маской
        // выделяем два операнда, литерал и тип команды
        // (тип "0" - пустая команда)
            op2 = (cmd & (op1_max-1));
            op1 = (cmd >> op1_size) & (op2_max-1);
        literal = (cmd >> (op1_size + op2_size)) & (literal_max-1);
        cmdtype = (cmd >> (op1_size + op2_size + literal_size));

        // Арифметические и логические операции (1-8)
        if (cmdtype >= ADD && cmdtype <= SHR) {
            switch (cmdtype) {
                case ADD : reg[op1]  = reg[op1]  +  reg[op2]; break; // Сложение
                case SUB : reg[op1]  = reg[op1]  -  reg[op2]; break; // Вычитание
                case AND : reg[op1]  = reg[op1] and reg[op2]; break; // Побитовое "И"
                case OR  : reg[op1]  = reg[op1] or  reg[op2]; break; // Побитовое "ИЛИ"
                case XOR : reg[op1]  = reg[op1] xor reg[op2]; break; // Побитовое "Сложение по модулю 2"
                case NOT : reg[op1]  = not reg[op1];          break; // Отрицание
                case SHL : reg[op1]  = reg[op1] << reg[op2];  break; // Сдвиг на op2 разрядов влево
                case SHR : reg[op1]  = reg[op1] >> reg[op2];  break; // Сдвиг на op1 разрядов вправо
                 default : break;
            }

            // Выставление флагов после операций
            // TODO: Добавить переполнение
            if (reg[op1] == 0) reg[FLAG] |= EZ;
            if (reg[op1]  > 0) reg[FLAG] |= GZ;
            if (reg[op1]  < 0) reg[FLAG] |= EZ;
        }

        // Другие операции (9-18)
        else {
            switch (cmdtype) {
                // Взаимодействие между регистрами/ячейками памяти данных
                case IREG :  reg[op1] =   literal; break; // Копирование непосредственного значения в регистр
                case IMEM : dmem[op1] =   literal; break; // Копирование непосредственного значения в память
                case RTR  :  reg[op1] =  reg[op2]; break; // Копирование с одного регистра на другой регистр
                case MTM  : dmem[op1] = dmem[op2]; break; // Копирование с одной ячейки памяти в другую ячейку памяти
                case RTM  :  reg[op1] = dmem[op2]; break; // Копирование с регистра в ячейку памяти
                case MTR  : dmem[op1] =  reg[op2]; break; // Копирование из ячейки памяти в регистр

                // Операции условного перехода (если выполняется, на счётчик команд поступает
                // значение литерала, в противном случае счётчик команд инкрементируется)
                case JEZ : pc = (reg[FLAG] & EZ) ? literal : pc + 1; break; // Значение на reg[op1] >  0
                case JGZ : pc = (reg[FLAG] & GZ) ? literal : pc + 1; break; // Значение на reg[op1] <  0
                case JLZ : pc = (reg[FLAG] & EZ) ? literal : pc + 1; break; // Значение на reg[op1] == 0
                case JP  : pc = literal;                             break; // безусловный переход

                default : break;
            }
        }

        cout <<  "Счётчик команд: ";
        print_binary(pc, cmem_addr_size);
        cout << endl << "Текущая команда:" << endl;
        cout << "Тип команды | Литерал\t\t| 1-ый адрес | 2-ой адрес |" << endl;
        print_binary(cmdtype, cmem_addr_size);  cout << "\t    | ";
        print_binary(literal, literal_size);    cout << " | ";
        print_binary(op1, op1_size);            cout << "      | ";
        print_binary(op2, op2_size);            cout << "       |" << endl;

        output_debug(output_debug_settings);

        cout << endl;
        //cout << "\"Стрелка вверх\" - предыдущая команда, ";
        cout << "\"Стрелка вниз\" - следующая команда, ";
        cout << "\"O\" - настройки, ";
        cout << "\"Q\" - закончить работу процессора";
        while (!next_flag && !end_flag) {
            switch(key = getch()) {
                // Предыдущая команда?
                // case KEY_UP   :  prev_flag = true; break;
                case KEY_DOWN :  next_flag = true; break;
                case KEY_O    : debug_flag = true; break;
                case KEY_Q    :   end_flag = true; break;
                default: break;
            }

            if (debug_flag) {
                config_output_debug();
                debug_flag = false;
            }
        }

        if (!end_flag) {
            key = 0;
            next_flag = false;
            debug_flag = false;
            pc = pc + 1;
            cout << '\r';
            // Сброс счётчик команд при достижении
            // последнего адреса в памяти команд
            if (pc > cmem_size) pc = 0;
        }
    }
}

// Функция для отладочных выводов
void output_debug(char settings) {

    if (settings & 1) {
        cout << endl << "Регистры:" << endl;
        cout << "Значения регистра флагов: ";
        print_binary(reg[FLAG], reg_data_size); cout << endl;
        print_mem(reg, reg_size, reg_addr_size, reg_data_size, 4);
}

    if (settings & 2) {
        cout << endl << "Память команд:" << endl;
        print_mem(cmem, cmem_size, cmem_addr_size, cmem_data_size, 4);
    }

    if (settings & 4) {
        cout << endl << "Память данных:" << endl;
        print_mem(dmem, dmem_size, dmem_addr_size, dmem_data_size, 4);
    }
}

/** -------------------------------------------------------------- *
    ОПРЕДЕЛЕНИЕ ФУНКЦИЙ ДЛЯ СОХРАНЕНИЯ И ЗАГРУЗКИ СОСТОЯНИЯ МОДЕЛИ
  * -------------------------------------------------------------- */

// Функция для загрузки сохранённого состояния модели
void load_saved_state() {
    bool accept_flag, key_flag;
    int key;

    cout << "Вы хотите загрузить состояние модели? (Y/N) ";
    while(!key_flag) {
        switch(key = getch()) {
            case KEY_Y:
                key_flag = true;
                accept_flag = true;
                break;
            case KEY_N:
                key_flag = true;
                break;
            default:
                break;
        }
    }

    if (accept_flag) {
        cout << endl << "Загрузка ранее сохранённого состояния памяти команд и памяти данных..." << endl;
        string saved_prog_memory, saved_data_memory;
        string colon = ":";
        regex line_regex("[^\\n]+");

        cout << "1. Файл памяти команд";
        saved_prog_memory = get_info_from_file();
        auto file_begin = sregex_iterator(saved_prog_memory.begin(), saved_prog_memory.end(), line_regex);
        auto file_end = sregex_iterator();
        for (auto i = file_begin; i != file_end; ++i) {
            string cmd = (*i).str();
            string addr = cmd.substr(0, cmd.find(colon));
            cmd.erase(0, cmd.find(colon) + 1);
            cmem[stoi(addr)] = stoi(cmd);
        }

        cout << "2. Файл памяти данных";
        saved_data_memory = get_info_from_file();
        file_begin = sregex_iterator(saved_data_memory.begin(), saved_data_memory.end(), line_regex);
        file_end = sregex_iterator();
        for (auto i = file_begin; i != file_end; ++i) {
            string data = (*i).str();
            string addr = data.substr(0, data.find(colon));
            data.erase(0, data.find(colon) + 1);
            dmem[stoi(addr)] = stoi(data);
        }

        cout << "Сохранённое состояние памяти восстановлено.";
    }
    cout << endl << endl;
}

// Функция сохранения состояния модели
void save_current_state() {
    bool accept_flag, key_flag;
    int key;

    // Вопрос о подтверждении сохранения состояния
    cout << "Вы хотите сохранить состояние модели? (Y/N) ";
    while(!key_flag) {
        switch(key = getch()) {
            case KEY_Y:
                key_flag = true;
                accept_flag = true;
                break;
            case KEY_N:
                key_flag = true;
                break;
            default:
                break;
        }
    }

    // Если есть подтверждение сохранения состояния
    if (accept_flag) {
        string memory_info = "";
        for (int i = 0; i < cmem_size; i++)
            memory_info += to_string(i) + ":" + to_string(cmem[i]) + "\n";

        cout << endl << "Сохранение памяти команд." << endl;
        save_info_in_file(memory_info);

        memory_info = "";
        for (int i = 0; i < dmem_size; i++)
            memory_info += to_string(i) + ":" + to_string(dmem[i]) + "\n";

        cout << endl << "Сохранение памяти данных." << endl;
        save_info_in_file(memory_info);
    }
}





































/*// Вычисление размера адреса памяти
unsigned short int compute_addr_size(unsigned short int mem_size) {
    int addr_size = 0;
    while(mem_size != 1) {mem_size >>= 1; addr_size++;}
    return addr_size;
}*/


  //   if(_getch()==32) system("Pause"); //установка программы на паузу пробелом с ожиданием нажатия клавиши
  //    if(_getch()==83) system("cls"); //очистка экрана при нажатии клавиши del
  //cmd = cmem[pc];
  //op1=(cmd>>4)&15 //сохранение значения первой переменной находящейся в разрядах 7-4
  //op2=cmd&15 //сохранение значения второй переменной находящейся в разрядах 3-0*/
                // Операции копирования
//TODO : template
